# Multithreading in Python

---

## üîπ What is Multithreading?
- **Thread** ‚Üí a lightweight unit of execution within a process.  
- **Multithreading** allows multiple tasks to run "concurrently" within the same program.  
- Useful for **I/O-bound tasks** (e.g., file reading, API calls, database queries).  

‚ö†Ô∏è Note: Python has the **Global Interpreter Lock (GIL)** which limits true parallelism for CPU-bound tasks.  
For CPU-heavy tasks, use **multiprocessing** instead.  

---

## üîπ Why Multithreading?
- Improves responsiveness.  
- Handles multiple tasks simultaneously (e.g., downloading files, serving clients).  
- Efficient for programs waiting on external resources.  

---

## üîπ Creating Threads with `threading` Module
```python
import threading

def print_numbers():
    for i in range(5):
        print("Number:", i)

def print_letters():
    for ch in ['A', 'B', 'C', 'D', 'E']:
        print("Letter:", ch)

# Create threads
t1 = threading.Thread(target=print_numbers)
t2 = threading.Thread(target=print_letters)

# Start threads
t1.start()
t2.start()

# Wait for threads to finish
t1.join()
t2.join()

print("Done!")
```

---

## üîπ Using `Lock` to Prevent Race Conditions
```python
import threading

balance = 0
lock = threading.Lock()

def deposit():
    global balance
    for _ in range(100000):
        with lock:  # ensures only one thread modifies balance at a time
            balance += 1

t1 = threading.Thread(target=deposit)
t2 = threading.Thread(target=deposit)

t1.start()
t2.start()
t1.join()
t2.join()

print("Final Balance:", balance)  # Expected: 200000
```

---

## üîπ Using `concurrent.futures` (Simpler API)
```python
import concurrent.futures
import time

def task(n):
    time.sleep(1)
    return f"Task {n} done"

with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
    results = executor.map(task, range(5))

for r in results:
    print(r)
```

Output:
```
Task 0 done
Task 1 done
Task 2 done
Task 3 done
Task 4 done
```
---

## üîπ Using `concurrent.futures` (Without Lock (Race Condition))
```python
from concurrent.futures import ThreadPoolExecutor
import random,time

balance = 0

def deposit():
    global balance
    for _ in range(100000):
        time.sleep(random.random() * 0.00001)  # random tiny delay
        balance += 1   # ‚ö†Ô∏è Not thread-safe
        
with ThreadPoolExecutor(max_workers=10) as executor:
    for _ in range(10):   # 10 threads depositing
        executor.submit(deposit)

print("Final Balance WITHOUT Lock:", balance, "(Expected: 1,000,000)")
```


---

## üîπ Using `concurrent.futures` (With Lock (Thread-Safe))
```python
from concurrent.futures import ThreadPoolExecutor
import threading
import random,time

balance = 0
lock = threading.Lock()

def deposit_with_lock():
    global balance
    for _ in range(100000):
        time.sleep(random.random() * 0.00001)  # random tiny delay
        with lock:  # ensures only one thread modifies at a time
            balance += 1
        

with ThreadPoolExecutor(max_workers=10) as executor:
    for _ in range(10):   # 10 threads depositing
        executor.submit(deposit_with_lock)

print("Final Balance WITH Lock:", balance, "(Expected: 1,000,000)")
```


---

## üîπ COBOL / Java / C# Mapping
| Concept | COBOL | Java / C# | Python |
|---------|-------|-----------|--------|
| Concurrency | Batch jobs (sequential) | `Thread`, `Executor`, `Task` | `threading`, `concurrent.futures` |
| Race Conditions | Not relevant | Synchronization (`synchronized`, `lock`) | `threading.Lock` |
| Thread Pools | Not available | ExecutorService, ThreadPool | `ThreadPoolExecutor` |

---

## üí° Exercises
1. Write a program that creates two threads: one prints even numbers, another prints odd numbers up to 20.  
2. Create a shared counter updated by 5 threads. Use `Lock` to avoid race conditions.  
3. Use `ThreadPoolExecutor` to simulate downloading 5 files in parallel.  
4. Compare execution time of sequential vs threaded execution of a function that sleeps for 2 seconds.  

---
