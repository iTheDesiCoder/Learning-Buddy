@startuml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

LAYOUT_TOP_DOWN()

title **Multithreading vs Multiprocessing in Python**\n<size:12>Understanding Concurrency and Parallelism</size>

Person(dev, "Python Developer", "Needs to handle multiple tasks")

System_Boundary(mt, "üßµ **MULTITHREADING**") {
    Container(gil, "üîí Global Interpreter Lock (GIL)", "Python Limitation", "Only one thread executes Python code at a time")
    Container(proc_mt, "Python Process", "Single Process", "One interpreter instance")
    Container(sharedMem, "üíæ Shared Memory", "RAM", "All threads share variables & objects")
    
    Container(thread1, "Thread-1", "I/O Bound Task", "File reading, Network calls")
    Container(thread2, "Thread-2", "I/O Bound Task", "Database queries, API calls")
    
    Container(adv_mt, "‚úÖ **ADVANTAGES**", "Benefits", "‚Ä¢ Fast context switching\n‚Ä¢ Low memory overhead\n‚Ä¢ Easy data sharing")
    Container(dis_mt, "‚ùå **LIMITATIONS**", "Drawbacks", "‚Ä¢ GIL prevents true parallelism\n‚Ä¢ Not good for CPU-intensive tasks\n‚Ä¢ Race conditions possible")
    
    Rel(dev, proc_mt, "Starts program")
    Rel(proc_mt, gil, "Controlled by")
    Rel(proc_mt, thread1, "Creates", "threading.Thread()")
    Rel(proc_mt, thread2, "Creates", "threading.Thread()")
    Rel(thread1, sharedMem, "Shares data", "Direct access")
    Rel(thread2, sharedMem, "Shares data", "Direct access")
    Rel(gil, thread1, "Allows execution", "When I/O occurs")
    Rel(gil, thread2, "Allows execution", "When I/O occurs")
}

System_Boundary(mp, "‚ö° **MULTIPROCESSING**") {
    Container(proc1, "Process-1", "Independent Python Process", "Own interpreter & GIL")
    Container(proc2, "Process-2", "Independent Python Process", "Own interpreter & GIL")
    
    Container(mem1, "üíæ Memory-1", "Private RAM", "Isolated variables & objects")
    Container(mem2, "üíæ Memory-2", "Private RAM", "Isolated variables & objects")
    
    Container(cpu1, "üñ•Ô∏è CPU Core-1", "Physical Core", "True parallel execution")
    Container(cpu2, "üñ•Ô∏è CPU Core-2", "Physical Core", "True parallel execution")
    
    Container(ipc, "üì° Inter-Process Communication", "Data Exchange", "Queue, Pipe, Manager")
    
    Container(adv_mp, "‚úÖ **ADVANTAGES**", "Benefits", "‚Ä¢ True parallelism\n‚Ä¢ No GIL limitations\n‚Ä¢ Great for CPU-intensive tasks\n‚Ä¢ Fault isolation")
    Container(dis_mp, "‚ùå **LIMITATIONS**", "Drawbacks", "‚Ä¢ Higher memory usage\n‚Ä¢ Slower process creation\n‚Ä¢ Complex data sharing\n‚Ä¢ Serialization overhead")
    
    Rel(dev, proc1, "Starts process", "multiprocessing.Process()")
    Rel(dev, proc2, "Starts process", "multiprocessing.Process()")
    Rel(proc1, mem1, "Uses exclusively")
    Rel(proc2, mem2, "Uses exclusively")
    Rel(proc1, cpu1, "Executes on", "Parallel")
    Rel(proc2, cpu2, "Executes on", "Parallel")
    Rel(proc1, ipc, "Communicates via", "pickle/serialize")
    Rel(proc2, ipc, "Communicates via", "pickle/serialize")
}

System_Boundary(guide, "üìö **WHEN TO USE WHAT?**") {
    Container(io_tasks, "üîÑ I/O Bound Tasks", "Use Threading", "‚Ä¢ File operations\n‚Ä¢ Network requests\n‚Ä¢ Database queries\n‚Ä¢ Web scraping")
    Container(cpu_tasks, "üßÆ CPU Bound Tasks", "Use Multiprocessing", "‚Ä¢ Mathematical calculations\n‚Ä¢ Image processing\n‚Ä¢ Data analysis\n‚Ä¢ Machine learning")
    
    Container(code_mt, "üíª Threading Code", "Example", 'import threading\n\ndef io_task():\n    # Network call\n    time.sleep(1)\n\nthreads = []\nfor i in range(5):\n    t = threading.Thread(target=io_task)\n    threads.append(t)\n    t.start()')
    
    Container(code_mp, "üíª Multiprocessing Code", "Example", 'import multiprocessing\n\ndef cpu_task(n):\n    # Heavy calculation\n    return sum(i*i for i in range(n))\n\nif __name__ == "__main__":\n    with multiprocessing.Pool() as pool:\n        results = pool.map(cpu_task, [1000000] * 4)')
}

Rel(mt, guide, "Choose based on task type")
Rel(mp, guide, "Choose based on task type")

@enduml
